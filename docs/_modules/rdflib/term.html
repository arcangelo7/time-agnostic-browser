
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>rdflib.term &#8212; Time Agnostic Browser  documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/material.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=blue-grey data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/rdflib/term" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../index.html" title="Time Agnostic Browser  documentation"
           class="md-header-nav__button md-logo">
          
            &nbsp;
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">Time Agnostic Browser  documentation</span>
          <span class="md-header-nav__topic"> rdflib.term </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
      
  
  <script src="../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../"versions.json"",
        target_loc = "../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../index.html" class="md-tabs__link">Time Agnostic Browser  documentation</a></li>
          <li class="md-tabs__item"><a href="../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../index.html" title="Time Agnostic Browser documentation" class="md-nav__button md-logo">
      
        <img src="../../_static/" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../index.html"
       title="Time Agnostic Browser documentation">Time Agnostic Browser  documentation</a>
  </label>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-rdflib-term--page-root">Source code for rdflib.term</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">This module defines the different types of terms. Terms are the kinds of</span>
<span class="sd">objects that can appear in a quoted/asserted triple. This includes those</span>
<span class="sd">that are core to RDF:</span>

<span class="sd">* :class:`Blank Nodes &lt;rdflib.term.BNode&gt;`</span>
<span class="sd">* :class:`URI References &lt;rdflib.term.URIRef&gt;`</span>
<span class="sd">* :class:`Literals &lt;rdflib.term.Literal&gt;` (which consist of a literal value,datatype and language tag)</span>

<span class="sd">Those that extend the RDF model into N3:</span>

<span class="sd">* :class:`Formulae &lt;rdflib.graph.QuotedGraph&gt;`</span>
<span class="sd">* :class:`Universal Quantifications (Variables) &lt;rdflib.term.Variable&gt;`</span>

<span class="sd">And those that are primarily for matching against 'Nodes' in the</span>
<span class="sd">underlying Graph:</span>

<span class="sd">* REGEX Expressions</span>
<span class="sd">* Date Ranges</span>
<span class="sd">* Numerical Ranges</span>

<span class="sd">"""</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="c1"># from __future__ import unicode_literals</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">'bind'</span><span class="p">,</span>

    <span class="s1">'Node'</span><span class="p">,</span>
    <span class="s1">'Identifier'</span><span class="p">,</span>

    <span class="s1">'URIRef'</span><span class="p">,</span>
    <span class="s1">'BNode'</span><span class="p">,</span>
    <span class="s1">'Literal'</span><span class="p">,</span>

    <span class="s1">'Variable'</span><span class="p">,</span>
    <span class="s1">'Statement'</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">xml.dom.minidom</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">sub</span><span class="p">,</span> <span class="nb">compile</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">unicodedata</span> <span class="kn">import</span> <span class="n">category</span>

<span class="kn">from</span> <span class="nn">isodate</span> <span class="kn">import</span> <span class="n">parse_time</span><span class="p">,</span> <span class="n">parse_date</span><span class="p">,</span> <span class="n">parse_datetime</span><span class="p">,</span> <span class="n">Duration</span><span class="p">,</span> <span class="n">parse_duration</span><span class="p">,</span> <span class="n">duration_isoformat</span>
<span class="kn">from</span> <span class="nn">binascii</span> <span class="kn">import</span> <span class="n">hexlify</span><span class="p">,</span> <span class="n">unhexlify</span>

<span class="kn">import</span> <span class="nn">rdflib</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">PY2</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">PY3</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">b</span>
<span class="kn">from</span> <span class="nn">rdflib.compat</span> <span class="kn">import</span> <span class="n">long_type</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">text_type</span>
<span class="kn">from</span> <span class="nn">six.moves.urllib.parse</span> <span class="kn">import</span> <span class="n">urldefrag</span>
<span class="kn">from</span> <span class="nn">six.moves.urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>
<span class="kn">from</span> <span class="nn">six.moves.urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>

<span class="n">skolem_genid</span> <span class="o">=</span> <span class="s2">"/.well-known/genid/"</span>
<span class="n">rdflib_skolem_genid</span> <span class="o">=</span> <span class="s2">"/.well-known/genid/rdflib/"</span>
<span class="n">skolems</span> <span class="o">=</span> <span class="p">{}</span>


<span class="n">_invalid_uri_chars</span> <span class="o">=</span> <span class="s1">'&lt;&gt;" </span><span class="si">{}</span><span class="s1">|</span><span class="se">\\</span><span class="s1">^`'</span>


<span class="k">def</span> <span class="nf">_is_valid_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">256</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_invalid_uri_chars</span><span class="p">,</span> <span class="n">uri</span><span class="p">))</span>


<span class="n">_lang_tag_regex</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="s1">'^[a-zA-Z]+(?:-[a-zA-Z0-9]+)*$'</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_valid_langtag</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_lang_tag_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_is_valid_unicode</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Verify that the provided value can be converted into a Python</span>
<span class="sd">    unicode object.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">'decode'</span><span class="p">),</span> <span class="s1">'utf-8'</span>
    <span class="k">elif</span> <span class="n">PY3</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">,</span> <span class="n">value</span>

    <span class="c1"># try to convert value into unicode</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A Node in the Graph.</span>
<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">Identifier</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">text_type</span><span class="p">):</span>  <span class="c1"># allow Identifiers to be Nodes in the Graph</span>
    <span class="sd">"""</span>
<span class="sd">    See http://www.w3.org/2002/07/rdf-identifer-terminology/</span>
<span class="sd">    regarding choice of terminology.</span>
<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""A "semantic"/interpreted equality function,</span>
<span class="sd">        by default, same as __eq__"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""A "semantic"/interpreted not equal function,</span>
<span class="sd">        by default, same as __ne__"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Equality for Nodes.</span>

<span class="sd">        &gt;&gt;&gt; BNode("foo")==None</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; BNode("foo")==URIRef("foo")</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; URIRef("foo")==BNode("foo")</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; BNode("foo")!=URIRef("foo")</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; URIRef("foo")!=BNode("foo")</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Variable('a')!=URIRef('a')</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Variable('a')!=Variable('a')</span>
<span class="sd">        False</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        This implements ordering for Nodes,</span>

<span class="sd">        This tries to implement this:</span>
<span class="sd">        http://www.w3.org/TR/sparql11-query/#modOrderBy</span>

<span class="sd">        Variables are not included in the SPARQL list, but</span>
<span class="sd">        they are greater than BNodes and smaller than everything else</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># everything bigger than None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)]</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Nothing is less than None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)]</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="c1"># use parent's hash for efficiency reasons</span>
    <span class="c1"># clashes of 'foo', URIRef('foo') and Literal('foo') are typically so rare</span>
    <span class="c1"># that they don't justify additional overhead. Notice that even in case of</span>
    <span class="c1"># clash __eq__ is still the fallback and very quick in those cases.</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__hash__</span>


<span class="k">class</span> <span class="nc">URIRef</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    RDF URI Reference: http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref</span>
<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ends_in_hash</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">"#"</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">urljoin</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">allow_fragments</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ends_in_hash</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">"#"</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">+=</span> <span class="s2">"#"</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_valid_uri</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1"> does not look like a valid URI, trying to serialize this will break.'</span><span class="o">%</span><span class="n">value</span><span class="p">)</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s1">'utf-8'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rt</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        This will do a limited check for valid URIs,</span>
<span class="sd">        essentially just making sure that the string includes no illegal</span>
<span class="sd">        characters (``&lt;, &gt;, ", {, }, |, \\, `, ^``)</span>

<span class="sd">        :param namespace_manager: if not None, will be used to make up</span>
<span class="sd">             a prefixed name</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_valid_uri</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'"</span><span class="si">%s</span><span class="s1">" does not look like a valid URI, I cannot serialize this as N3/Turtle. Perhaps you wanted to urlencode it?'</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">namespace_manager</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">namespace_manager</span><span class="o">.</span><span class="n">normalizeUri</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">"&lt;</span><span class="si">%s</span><span class="s2">&gt;"</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">defrag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">"#"</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">frag</span> <span class="o">=</span> <span class="n">urldefrag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">URIRef</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">URIRef</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">"rdflib.term.URIRef"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">return</span> <span class="s2">"""</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)"""</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">URIRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">de_skolemize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">""" Create a Blank Node from a skolem URI, in accordance</span>
<span class="sd">        with http://www.w3.org/TR/rdf11-concepts/#section-skolemization.</span>
<span class="sd">        This function accepts only rdflib type skolemization, to provide</span>
<span class="sd">        a round-tripping within the system.</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RDFLibGenid</span><span class="p">):</span>
            <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BNode</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rdflib_skolem_genid</span><span class="p">):])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Genid</span><span class="p">):</span>
            <span class="n">bnode_id</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">bnode_id</span> <span class="ow">in</span> <span class="n">skolems</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">skolems</span><span class="p">[</span><span class="n">bnode_id</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span> <span class="o">=</span> <span class="n">BNode</span><span class="p">()</span>
                <span class="n">skolems</span><span class="p">[</span><span class="n">bnode_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>
                <span class="k">return</span> <span class="n">retval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"&lt;</span><span class="si">%s</span><span class="s2">&gt; is not a skolem URI"</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Genid</span><span class="p">(</span><span class="n">URIRef</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_external_skolem</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">uri</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">gen_id</span> <span class="o">=</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">skolem_genid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">RDFLibGenid</span><span class="p">(</span><span class="n">Genid</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_rdflib_skolem</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">uri</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">params</span> <span class="o">!=</span> <span class="s2">""</span> \
                <span class="ow">or</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">query</span> <span class="o">!=</span> <span class="s2">""</span> \
                <span class="ow">or</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">fragment</span> <span class="o">!=</span> <span class="s2">""</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">gen_id</span> <span class="o">=</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">rdflib_skolem_genid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_unique_id</span><span class="p">():</span>
    <span class="c1"># Used to read: """Create a (hopefully) unique prefix"""</span>
    <span class="c1"># now retained merely to leave interal API unchanged.</span>
    <span class="c1"># From BNode.__new__() below ...</span>
    <span class="c1">#</span>
    <span class="c1"># acceptable bnode value range for RDF/XML needs to be</span>
    <span class="c1"># something that can be serialzed as a nodeID for N3</span>
    <span class="c1">#</span>
    <span class="c1"># BNode identifiers must be valid NCNames" _:[A-Za-z][A-Za-z0-9]*</span>
    <span class="c1"># http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/#nodeID</span>
    <span class="k">return</span> <span class="s2">"N"</span>  <span class="c1"># ensure that id starts with a letter</span>


<span class="k">def</span> <span class="nf">_serial_number_generator</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    Generates UUID4-based but ncname-compliant identifiers.</span>
<span class="sd">    """</span>
    <span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>

    <span class="k">def</span> <span class="nf">_generator</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span>

    <span class="k">return</span> <span class="n">_generator</span>


<span class="k">class</span> <span class="nc">BNode</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Blank Node: http://www.w3.org/TR/rdf-concepts/#section-blank-nodes</span>

<span class="sd">    """</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">_sn_gen</span><span class="o">=</span><span class="n">_serial_number_generator</span><span class="p">(),</span> <span class="n">_prefix</span><span class="o">=</span><span class="n">_unique_id</span><span class="p">()):</span>
        <span class="sd">"""</span>
<span class="sd">        # only store implementations should pass in a value</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># so that BNode values do not collide with ones created with</span>
            <span class="c1"># a different instance of this module at some other time.</span>
            <span class="n">node_id</span> <span class="o">=</span> <span class="n">_sn_gen</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%s%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">_prefix</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: check that value falls within acceptable bnode value range</span>
            <span class="c1"># for RDF/XML needs to be something that can be serialzed</span>
            <span class="c1"># as a nodeID for N3 ??  Unless we require these</span>
            <span class="c1"># constraints be enforced elsewhere?</span>
            <span class="k">pass</span>  <span class="c1"># assert is_ncname(text_type(value)), "BNode identifiers</span>
            <span class="c1"># must be valid NCNames" _:[A-Za-z][A-Za-z0-9]*</span>
            <span class="c1"># http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/#nodeID</span>
        <span class="k">return</span> <span class="n">Identifier</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"_:</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">BNode</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">BNode</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">"rdflib.term.BNode"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">"""</span><span class="si">%s</span><span class="s2">('</span><span class="si">%s</span><span class="s2">')"""</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">skolemize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">authority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basepath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">""" Create a URIRef "skolem" representation of the BNode, in accordance</span>
<span class="sd">        with http://www.w3.org/TR/rdf11-concepts/#section-skolemization</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">authority</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">authority</span> <span class="o">=</span> <span class="s2">"http://rdlib.net/"</span>
        <span class="k">if</span> <span class="n">basepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basepath</span> <span class="o">=</span> <span class="n">rdflib_skolem_genid</span>
        <span class="n">skolem</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%s%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">urljoin</span><span class="p">(</span><span class="n">authority</span><span class="p">,</span> <span class="n">skolem</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    RDF Literal: http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal</span>

<span class="s2">    The lexical value of the literal is the unicode object</span>
<span class="s2">    The interpreted, datatyped value is available from .value</span>

<span class="s2">    Language tags must be valid according to :rfc:5646</span>

<span class="s2">    For valid XSD datatypes, the lexical form is optionally normalized</span>
<span class="s2">    at construction time. Default behaviour is set by rdflib.NORMALIZE_LITERALS</span>
<span class="s2">    and can be overridden by the normalize parameter to __new__</span>

<span class="s2">    Equality and hashing of Literals are done based on the lexical form, i.e.:</span>

<span class="s2">    &gt;&gt;&gt; from rdflib.namespace import XSD</span>

<span class="s2">    &gt;&gt;&gt; Literal('01')!=Literal('1') # clear - strings differ</span>
<span class="s2">    True</span>

<span class="s2">    but with data-type they get normalized:</span>

<span class="s2">    &gt;&gt;&gt; Literal('01', datatype=XSD.integer)!=Literal('1', datatype=XSD.integer)</span>
<span class="s2">    False</span>

<span class="s2">    unless disabled:</span>

<span class="s2">    &gt;&gt;&gt; Literal('01', datatype=XSD.integer, normalize=False)!=Literal('1', datatype=XSD.integer)</span>
<span class="s2">    True</span>


<span class="s2">    Value based comparison is possible:</span>

<span class="s2">    &gt;&gt;&gt; Literal('01', datatype=XSD.integer).eq(Literal('1', datatype=XSD.float))</span>
<span class="s2">    True</span>

<span class="s2">    The eq method also provides limited support for basic python types:</span>

<span class="s2">    &gt;&gt;&gt; Literal(1).eq(1) # fine - int compatible with xsd:integer</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal('a').eq('b') # fine - str compatible with plain-lit</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal('a', datatype=XSD.string).eq('a') # fine - str compatible with xsd:string</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal('a').eq(1) # not fine, int incompatible with plain-lit</span>
<span class="s2">    NotImplemented</span>

<span class="s2">    Greater-than/less-than ordering comparisons are also done in value</span>
<span class="s2">    space, when compatible datatypes are used.  Incompatible datatypes</span>
<span class="s2">    are ordered by DT, or by lang-tag.  For other nodes the ordering</span>
<span class="s2">    is None &lt; BNode &lt; URIRef &lt; Literal</span>

<span class="s2">    Any comparison with non-rdflib Node are "NotImplemented"</span>
<span class="s2">    In PY2.X some stable order will be made up by python</span>

<span class="s2">    In PY3 this is an error.</span>

<span class="s2">    &gt;&gt;&gt; from rdflib import Literal, XSD</span>
<span class="s2">    &gt;&gt;&gt; lit2006 = Literal('2006-01-01',datatype=XSD.date)</span>
<span class="s2">    &gt;&gt;&gt; lit2006.toPython()</span>
<span class="s2">    datetime.date(2006, 1, 1)</span>
<span class="s2">    &gt;&gt;&gt; lit2006 &lt; Literal('2007-01-01',datatype=XSD.date)</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(datetime.utcnow()).datatype</span>
<span class="s2">    rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#dateTime')</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; Literal(2) # by value</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; Literal(2.0) # by value</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal('1') &gt; Literal(1) # by DT</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal('1') &lt; Literal('1') # by lexical form</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal('a', lang='en') &gt; Literal('a', lang='fr') # by lang-tag</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; URIRef('foo') # by node-type</span>
<span class="s2">    True</span>

<span class="s2">    The &gt; &lt; operators will eat this NotImplemented and either make up</span>
<span class="s2">    an ordering (py2.x) or throw a TypeError (py3k):</span>

<span class="s2">    &gt;&gt;&gt; Literal(1).__gt__(2.0)</span>
<span class="s2">    NotImplemented</span>


<span class="s2">    """</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">PY3</span><span class="p">:</span>
        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"language"</span><span class="p">,</span> <span class="s2">"datatype"</span><span class="p">,</span> <span class="s2">"value"</span><span class="p">,</span> <span class="s2">"_language"</span><span class="p">,</span>
                     <span class="s2">"_datatype"</span><span class="p">,</span> <span class="s2">"_value"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"_language"</span><span class="p">,</span> <span class="s2">"_datatype"</span><span class="p">,</span> <span class="s2">"_value"</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">''</span><span class="p">:</span>
            <span class="n">lang</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># no empty lang-tags in RDF</span>

        <span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span> <span class="k">if</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">NORMALIZE_LITERALS</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">datatype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">"A Literal can only have one of lang or datatype, "</span>
                <span class="s2">"per http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_valid_langtag</span><span class="p">(</span><span class="n">lang</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"'</span><span class="si">%s</span><span class="s2">' is not a valid language tag!"</span> <span class="o">%</span> <span class="n">lang</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">datatype</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="c1"># create from another Literal instance</span>

            <span class="n">lang</span> <span class="o">=</span> <span class="n">lang</span> <span class="ow">or</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">language</span>
            <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
                <span class="c1"># override datatype</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">datatype</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">datatype</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">value</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="c1"># passed a string</span>
                <span class="c1"># try parsing lexical form of datatyped literal</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">_value</span><span class="p">,</span> <span class="n">_datatype</span> <span class="o">=</span> <span class="n">_castPythonToLiteral</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_is_valid_unicode</span><span class="p">(</span><span class="n">_value</span><span class="p">):</span>
                    <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">_value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># passed some python object</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">lexical_or_value</span>
            <span class="n">_value</span><span class="p">,</span> <span class="n">_datatype</span> <span class="o">=</span> <span class="n">_castPythonToLiteral</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>

            <span class="n">datatype</span> <span class="o">=</span> <span class="n">datatype</span> <span class="ow">or</span> <span class="n">_datatype</span>
            <span class="k">if</span> <span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">_value</span>
            <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
                <span class="n">lang</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">,</span> <span class="s1">'utf-8'</span><span class="p">)</span>

        <span class="n">inst</span><span class="o">.</span><span class="n">_language</span> <span class="o">=</span> <span class="n">lang</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_datatype</span> <span class="o">=</span> <span class="n">datatype</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">inst</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a new literal with a normalised lexical representation</span>
<span class="sd">        of this literal</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal("01", datatype=XSD.integer, normalize=False).normalize()</span>
<span class="sd">        rdflib.term.Literal(u'1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        Illegal lexical forms for the datatype given are simply passed on</span>
<span class="sd">        &gt;&gt;&gt; Literal("a", datatype=XSD.integer, normalize=False)</span>
<span class="sd">        rdflib.term.Literal(u'a', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">language</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_language</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">datatype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datatype</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_language</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">"language"</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datatype</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">"datatype"</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; Literal(1) + 1</span>
<span class="sd">        rdflib.term.Literal(u'2', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>
<span class="sd">        &gt;&gt;&gt; Literal("1") + "1"</span>
<span class="sd">        rdflib.term.Literal(u'11')</span>
<span class="sd">        """</span>

        <span class="c1"># if no val is supplied, return this Literal</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># convert the val to a Literal, if it isn't already one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># if the datatypes are the same, just add the Python values and convert back</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toPython</span><span class="p">()</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="n">toPython</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span>
        <span class="c1"># if the datatypes are not the same but are both numeric, add the Python values and strip off decimal junk</span>
        <span class="c1"># (i.e. tiny numbers (more than 17 decimal places) and trailing zeros) and return as a decimal</span>
        <span class="k">elif</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span>
                <span class="ow">and</span>
                <span class="n">val</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span>
                <span class="n">Decimal</span><span class="p">(</span>
                    <span class="p">(</span><span class="s1">'</span><span class="si">%f</span><span class="s1">'</span> <span class="o">%</span> <span class="nb">round</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toPython</span><span class="p">())</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">toPython</span><span class="p">()),</span> <span class="mi">15</span><span class="p">))</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">'0'</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">datatype</span><span class="o">=</span><span class="n">_XSD_DECIMAL</span>
            <span class="p">)</span>
        <span class="c1"># in all other cases, perform string concatenation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># if the original datatype is string-like, use that</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_STRING_LITERAL_TYPES</span><span class="p">:</span>
                <span class="n">new_datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span>
            <span class="c1"># if not, use string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_datatype</span> <span class="o">=</span> <span class="n">_XSD_STRING</span>

            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">new_datatype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Is the Literal "True"</span>
<span class="sd">        This is used for if statements, bool(literal), etc.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(1))</span>
<span class="sd">        rdflib.term.Literal(u'-1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(10.5))</span>
<span class="sd">        rdflib.term.Literal(u'-10.5', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#double'))</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; (- Literal("1", datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u'-1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        &gt;&gt;&gt; (- Literal("1"))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u'1')</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__neg__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Not a number; </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(1))</span>
<span class="sd">        rdflib.term.Literal(u'1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(u'-1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal("-1", datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u'-1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        &gt;&gt;&gt; (+ Literal("1"))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u'1')</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__pos__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Not a number; </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; abs(Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(u'1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; abs( Literal("-1", datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u'1', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        &gt;&gt;&gt; abs(Literal("1"))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u'1')</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__abs__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Not a number; </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; ~(Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(u'0', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; ~( Literal("-1", datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u'0', datatype=rdflib.term.URIRef(u'http://www.w3.org/2001/XMLSchema#integer'))</span>

<span class="sd">        Not working:</span>

<span class="sd">        &gt;&gt;&gt; ~(Literal("1"))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u'1')</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__invert__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Not a number; </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>

<span class="sd">        This implements ordering for Literals,</span>
<span class="sd">        the other comparison methods delegate here</span>

<span class="sd">        This tries to implement this:</span>
<span class="sd">        http://www.w3.org/TR/sparql11-query/#modOrderBy</span>

<span class="sd">        In short, Literals with compatible data-types are ordered in value</span>
<span class="sd">        space, i.e.</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>

<span class="sd">        &gt;&gt;&gt; Literal(1) &gt; Literal(2) # int/int</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(2.0) &gt; Literal(1) # double/int</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; from decimal import Decimal</span>
<span class="sd">        &gt;&gt;&gt; Literal(Decimal("3.3")) &gt; Literal(2.0) # decimal/double</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(Decimal("3.3")) &lt; Literal(4.0) # decimal/double</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal('b') &gt; Literal('a') # plain lit/plain lit</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal('b') &gt; Literal('a', datatype=XSD.string) # plain lit/xsd:str</span>
<span class="sd">        True</span>

<span class="sd">        Incompatible datatype mismatches ordered by DT</span>

<span class="sd">        &gt;&gt;&gt; Literal(1) &gt; Literal("2") # int&gt;string</span>
<span class="sd">        False</span>

<span class="sd">        Langtagged literals by lang tag</span>
<span class="sd">        &gt;&gt;&gt; Literal("a", lang="en") &gt; Literal("a", lang="fr")</span>
<span class="sd">        False</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Everything is greater than None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span> <span class="ow">and</span> \
                    <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># plain-literals and xsd:string literals</span>
            <span class="c1"># are "the same"</span>
            <span class="n">dtself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>
            <span class="n">dtother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>

            <span class="k">if</span> <span class="n">dtself</span> <span class="o">!=</span> <span class="n">dtother</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">DAWG_LITERAL_COLLATION</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dtself</span> <span class="o">&gt;</span> <span class="n">dtother</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_TOTAL_ORDER_CASTERS</span><span class="p">:</span>
                    <span class="n">caster</span> <span class="o">=</span> <span class="n">_TOTAL_ORDER_CASTERS</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
                    <span class="k">return</span> <span class="n">caster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">caster</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="c1"># same language, same lexical form, check real dt</span>
            <span class="c1"># plain-literals come before xsd:string!</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span>

            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># they are the same</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Literal are the greatest!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># we can only compare to nodes</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Nothing is less than None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># all nodes are less-than Literals</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal('2007-01-01T10:00:00', datatype=XSD.dateTime</span>
<span class="sd">        ...     ) &lt;= Literal('2007-01-01T10:00:00', datatype=XSD.dateTime)</span>
<span class="sd">        True</span>
<span class="sd">        """</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_comparable_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Helper method to decide which things are meaningful to</span>
<span class="sd">        rich-compare with this literal</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">):</span>
                <span class="c1"># two datatyped literals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">XSDToPython</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">XSDToPython</span><span class="p">:</span>
                    <span class="c1"># non XSD DTs must match</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># xsd:string may be compared with plain literals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="c1"># if given lang-tag has to be case insensitive equal</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; a = {Literal('1', datatype=XSD.integer):'one'}</span>
<span class="sd">        &gt;&gt;&gt; Literal('1', datatype=XSD.double) in a</span>
<span class="sd">        False</span>


<span class="sd">        "Called for the key object for dictionary operations,</span>
<span class="sd">        and by the built-in function hash(). Should return</span>
<span class="sd">        a 32-bit integer usable as a hash value for</span>
<span class="sd">        dictionary operations. The only required property</span>
<span class="sd">        is that objects which compare equal have the same</span>
<span class="sd">        hash value; it is advised to somehow mix together</span>
<span class="sd">        (e.g., using exclusive or) the hash values for the</span>
<span class="sd">        components of the object that also play a part in</span>
<span class="sd">        comparison of objects." -- 3.4.1 Basic customization (Python)</span>

<span class="sd">        "Two literals are equal if and only if all of the following hold:</span>
<span class="sd">        * The strings of the two lexical forms compare equal, character by</span>
<span class="sd">        character.</span>
<span class="sd">        * Either both or neither have language tags.</span>
<span class="sd">        * The language tags, if any, compare equal.</span>
<span class="sd">        * Either both or neither have datatype URIs.</span>
<span class="sd">        * The two datatype URIs, if any, compare equal, character by</span>
<span class="sd">        character."</span>
<span class="sd">        -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)</span>

<span class="sd">        """</span>
        <span class="c1"># don't use super()... for efficiency reasons, see Identifier.__hash__</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Literals are only equal to other literals.</span>

<span class="sd">        "Two literals are equal if and only if all of the following hold:</span>
<span class="sd">        * The strings of the two lexical forms compare equal, character by character.</span>
<span class="sd">        * Either both or neither have language tags.</span>
<span class="sd">        * The language tags, if any, compare equal.</span>
<span class="sd">        * Either both or neither have datatype URIs.</span>
<span class="sd">        * The two datatype URIs, if any, compare equal, character by character."</span>
<span class="sd">        -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)</span>

<span class="sd">        &gt;&gt;&gt; Literal("1", datatype=URIRef("foo")) == Literal("1", datatype=URIRef("foo"))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal("1", datatype=URIRef("foo")) == Literal("1", datatype=URIRef("foo2"))</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; Literal("1", datatype=URIRef("foo")) == Literal("2", datatype=URIRef("foo"))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal("1", datatype=URIRef("foo")) == "asdf"</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal('2007-01-01', datatype=XSD.date) == Literal('2007-01-01', datatype=XSD.date)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal('2007-01-01', datatype=XSD.date) == date(2007, 1, 1)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal("one", lang="en") == Literal("one", lang="en")</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal("hast", lang='en') == Literal("hast", lang='de')</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal("1", datatype=XSD.integer) == Literal(1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal("1", datatype=XSD.integer) == Literal("01", datatype=XSD.integer)</span>
<span class="sd">        True</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compare the value of this literal with something else</span>

<span class="sd">        Either, with the value of another literal</span>
<span class="sd">        comparisons are then done in literal "value space",</span>
<span class="sd">        and according to the rules of XSD subtype-substitution/type-promotion</span>

<span class="sd">        OR, with a python object:</span>

<span class="sd">        basestring objects can be compared with plain-literals,</span>
<span class="sd">        or those with datatype xsd:string</span>

<span class="sd">        bool objects with xsd:boolean</span>

<span class="sd">        a int, long or float with numeric xsd types</span>

<span class="sd">        isodate date,time,datetime objects with xsd:date,xsd:time or xsd:datetime</span>

<span class="sd">        Any other operations returns NotImplemented</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span>  \
                    <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">'I cannot know that these two lexical forms do not map to the same value: </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">dtself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>
            <span class="n">dtother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dtself</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="n">dtother</span> <span class="o">==</span> <span class="n">_XSD_STRING</span><span class="p">):</span>
                <span class="c1"># string/plain literals, compare on lexical form</span>
                <span class="k">return</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dtself</span> <span class="o">!=</span> <span class="n">dtother</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">DAWG_LITERAL_COLLATION</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"I don't know how to compare literals with datatypes </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># matching non-string DTs now - do we compare values or</span>
            <span class="c1"># lexical form first?  comparing two ints is far quicker -</span>
            <span class="c1"># maybe there are counter examples</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_RDF_XMLLITERAL</span><span class="p">,</span> <span class="n">_RDF_HTMLLITERAL</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_isEqualXMLNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># string value space=lexical space</span>

                <span class="c1"># matching DTs, but not matching, we cannot compare!</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">'I cannot know that these two lexical forms do not map to the same value: </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># no non-Literal nodes are equal to a literal</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c1"># only plain-literals can be directly compared to strings</span>

            <span class="c1"># TODO: Is "blah"@en eq "blah" ?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">time</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_XSD_DATETIME</span><span class="p">,</span> <span class="n">_XSD_DATE</span><span class="p">,</span> <span class="n">_XSD_TIME</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">timedelta</span><span class="p">,</span> <span class="n">Duration</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_XSD_DURATION</span><span class="p">,</span> <span class="n">_XSD_DAYTIMEDURATION</span><span class="p">,</span> <span class="n">_XSD_YEARMONTHDURATION</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_BOOLEAN</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">'''</span>
<span class="sd">        Returns a representation in the N3 format.</span>

<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; Literal("foo").n3()</span>
<span class="sd">            u'"foo"'</span>

<span class="sd">        Strings with newlines or triple-quotes::</span>

<span class="sd">            &gt;&gt;&gt; Literal("foo\nbar").n3()</span>
<span class="sd">            u'"""foo\nbar"""'</span>

<span class="sd">            &gt;&gt;&gt; Literal("''\'").n3()</span>
<span class="sd">            u'"\'\'\'"'</span>

<span class="sd">            &gt;&gt;&gt; Literal('"""').n3()</span>
<span class="sd">            u'"\\"\\"\\""'</span>

<span class="sd">        Language::</span>

<span class="sd">            &gt;&gt;&gt; Literal("hello", lang="en").n3()</span>
<span class="sd">            u'"hello"@en'</span>

<span class="sd">        Datatypes::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1).n3()</span>
<span class="sd">            u'"1"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;'</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0).n3()</span>
<span class="sd">            u'"1.0"^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;'</span>

<span class="sd">            &gt;&gt;&gt; Literal(True).n3()</span>
<span class="sd">            u'"true"^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;'</span>

<span class="sd">        Datatype and language isn't allowed (datatype takes precedence)::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1, lang="en").n3()</span>
<span class="sd">            u'"1"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;'</span>

<span class="sd">        Custom datatype::</span>

<span class="sd">            &gt;&gt;&gt; footype = URIRef("http://example.org/ns#foo")</span>
<span class="sd">            &gt;&gt;&gt; Literal("1", datatype=footype).n3()</span>
<span class="sd">            u'"1"^^&lt;http://example.org/ns#foo&gt;'</span>

<span class="sd">        Passing a namespace-manager will use it to abbreviate datatype URIs:</span>

<span class="sd">            &gt;&gt;&gt; from rdflib import Graph</span>
<span class="sd">            &gt;&gt;&gt; Literal(1).n3(Graph().namespace_manager)</span>
<span class="sd">            u'"1"^^xsd:integer'</span>
<span class="sd">        '''</span>
        <span class="k">if</span> <span class="n">namespace_manager</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="n">qname_callback</span><span class="o">=</span><span class="n">namespace_manager</span><span class="o">.</span><span class="n">normalizeUri</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_literal_n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_plain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        Using plain literal (shorthand) output::</span>
<span class="sd">            &gt;&gt;&gt; from rdflib.namespace import XSD</span>

<span class="sd">            &gt;&gt;&gt; Literal(1)._literal_n3(use_plain=True)</span>
<span class="sd">            u'1'</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0)._literal_n3(use_plain=True)</span>
<span class="sd">            u'1e+00'</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0, datatype=XSD.decimal)._literal_n3(use_plain=True)</span>
<span class="sd">            u'1.0'</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0, datatype=XSD.float)._literal_n3(use_plain=True)</span>
<span class="sd">            u'"1.0"^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;'</span>

<span class="sd">            &gt;&gt;&gt; Literal("foo", datatype=XSD.string)._literal_n3(</span>
<span class="sd">            ...         use_plain=True)</span>
<span class="sd">            u'"foo"^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;'</span>

<span class="sd">            &gt;&gt;&gt; Literal(True)._literal_n3(use_plain=True)</span>
<span class="sd">            u'true'</span>

<span class="sd">            &gt;&gt;&gt; Literal(False)._literal_n3(use_plain=True)</span>
<span class="sd">            u'false'</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.91)._literal_n3(use_plain=True)</span>
<span class="sd">            u'1.91e+00'</span>

<span class="sd">            Only limited precision available for floats:</span>
<span class="sd">            &gt;&gt;&gt; Literal(0.123456789)._literal_n3(use_plain=True)</span>
<span class="sd">            u'1.234568e-01'</span>

<span class="sd">            &gt;&gt;&gt; Literal('0.123456789',</span>
<span class="sd">            ...     datatype=XSD.decimal)._literal_n3(use_plain=True)</span>
<span class="sd">            u'0.123456789'</span>

<span class="sd">        Using callback for datatype QNames::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1)._literal_n3(</span>
<span class="sd">            ...         qname_callback=lambda uri: "xsd:integer")</span>
<span class="sd">            u'"1"^^xsd:integer'</span>

<span class="sd">        '''</span>
        <span class="k">if</span> <span class="n">use_plain</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_PLAIN_LITERAL_TYPES</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If self is inf or NaN, we need a datatype</span>
                <span class="c1"># (there is no plain representation)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="p">)</span>

                <span class="c1"># this is a bit of a mess -</span>
                <span class="c1"># in py &gt;=2.6 the string.format function makes this easier</span>
                <span class="c1"># we try to produce "pretty" output</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_DOUBLE</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sub</span><span class="p">(</span><span class="s2">"</span><span class="se">\\</span><span class="s2">.?0*e"</span><span class="p">,</span> <span class="s2">"e"</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'</span><span class="si">%e</span><span class="s1">'</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_DECIMAL</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="s1">'.'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">+=</span> <span class="s1">'.0'</span>
                    <span class="k">return</span> <span class="n">s</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_BOOLEAN</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="sa">u</span><span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="sa">u</span><span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span>

        <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quote_encode</span><span class="p">()</span>

        <span class="n">datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span>
        <span class="n">quoted_dt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qname_callback</span><span class="p">:</span>
                <span class="n">quoted_dt</span> <span class="o">=</span> <span class="n">qname_callback</span><span class="p">(</span><span class="n">datatype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quoted_dt</span><span class="p">:</span>
                <span class="n">quoted_dt</span> <span class="o">=</span> <span class="s2">"&lt;</span><span class="si">%s</span><span class="s2">&gt;"</span> <span class="o">%</span> <span class="n">datatype</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="c1"># py string reps: float: 'inf', Decimal: 'Infinity"</span>
                        <span class="c1"># both need to become "INF" in xsd datatypes</span>
                        <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">,</span> <span class="s1">'INF'</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s1">'Infinity'</span><span class="p">,</span> <span class="s1">'INF'</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'nan'</span><span class="p">,</span> <span class="s1">'NaN'</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># if we can't cast to float something is wrong, but we can</span>
                    <span class="c1"># still serialize. Warn user about it</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"Serializing weird numerical </span><span class="si">%r</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">language</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span>
        <span class="k">if</span> <span class="n">language</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">^^</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">quoted_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">encoded</span>

    <span class="k">def</span> <span class="nf">_quote_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This simpler encoding doesn't work; a newline gets encoded as "\\n",</span>
        <span class="c1"># which is ok in sourcecode, but we want "\n".</span>
        <span class="c1"># encoded = self.encode('unicode-escape').replace(</span>
        <span class="c1">#        '\\', '\\\\').replace('"','\\"')</span>
        <span class="c1"># encoded = self.replace.replace('\\', '\\\\').replace('"','\\"')</span>

        <span class="c1"># NOTE: Could in theory chose quotes based on quotes appearing in the</span>
        <span class="c1"># string, i.e. '"' and "'", but N3/turtle doesn't allow "'"(?).</span>

        <span class="k">if</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Triple quote this string.</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'</span><span class="se">\\</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'</span><span class="se">\\\\</span><span class="s1">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">'"""'</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="c1"># is this ok?</span>
                <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'"""'</span><span class="p">,</span> <span class="s1">'</span><span class="se">\\</span><span class="s1">"</span><span class="se">\\</span><span class="s1">"</span><span class="se">\\</span><span class="s1">"'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">encoded</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'"'</span> <span class="ow">and</span> <span class="n">encoded</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'</span><span class="se">\\</span><span class="s1">'</span><span class="p">:</span>
                <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">'</span><span class="se">\\</span><span class="s1">'</span> <span class="o">+</span> <span class="s1">'"'</span>

            <span class="k">return</span> <span class="s1">'"""</span><span class="si">%s</span><span class="s1">"""'</span> <span class="o">%</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'</span><span class="se">\r</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'</span><span class="se">\\</span><span class="s1">r'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">'"</span><span class="si">%s</span><span class="s1">"'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'</span><span class="se">\\</span><span class="s1">n'</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s1">'</span><span class="se">\\</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'</span><span class="se">\\\\</span><span class="s1">'</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s1">'"'</span><span class="p">,</span> <span class="s1">'</span><span class="se">\\</span><span class="s1">"'</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s1">'</span><span class="se">\r</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'</span><span class="se">\\</span><span class="s1">r'</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span><span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"lang=</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"datatype=</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Literal</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">"rdflib.term.Literal"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">"""</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)"""</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns an appropriate python datatype derived from this RDF Literal</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">_parseXML</span><span class="p">(</span><span class="n">xmlstring</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="n">xmlstring</span> <span class="o">=</span> <span class="n">xmlstring</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">)</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span>
        <span class="s2">"&lt;rdflibtoplevelelement&gt;</span><span class="si">%s</span><span class="s2">&lt;/rdflibtoplevelelement&gt;"</span> <span class="o">%</span> <span class="n">xmlstring</span><span class="p">)</span>
    <span class="n">retval</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">retval</span>


<span class="k">def</span> <span class="nf">_parseHTML</span><span class="p">(</span><span class="n">htmltext</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">html5lib</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">html5lib</span><span class="o">.</span><span class="n">HTMLParser</span><span class="p">(</span>
            <span class="n">tree</span><span class="o">=</span><span class="n">html5lib</span><span class="o">.</span><span class="n">treebuilders</span><span class="o">.</span><span class="n">getTreeBuilder</span><span class="p">(</span><span class="s2">"dom"</span><span class="p">))</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parseFragment</span><span class="p">(</span><span class="n">htmltext</span><span class="p">)</span>
        <span class="n">retval</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">retval</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">"HTML5 parser not available. Try installing"</span> <span class="o">+</span>
            <span class="s2">" html5lib &lt;http://code.google.com/p/html5lib&gt;"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_writeXML</span><span class="p">(</span><span class="n">xmlnode</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xmlnode</span><span class="p">,</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">DocumentFragment</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">childNodes</span> <span class="o">+=</span> <span class="n">xmlnode</span><span class="o">.</span><span class="n">childNodes</span>
        <span class="n">xmlnode</span> <span class="o">=</span> <span class="n">d</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">xmlnode</span><span class="o">.</span><span class="n">toxml</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">)</span>
    <span class="c1"># for clean round-tripping, remove headers -- I have great and</span>
    <span class="c1"># specific worries that this will blow up later, but this margin</span>
    <span class="c1"># is too narrow to contain them</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s1">'&lt;?xml version="1.0" encoding="utf-8"?&gt;'</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">38</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s1">'&lt;rdflibtoplevelelement&gt;'</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">23</span><span class="p">:</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">b</span><span class="p">(</span><span class="s1">'&lt;rdflibtoplevelelement/&gt;'</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">_unhexlify</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="c1"># In Python 3.2, unhexlify does not support str (only bytes)</span>
    <span class="k">if</span> <span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">unhexlify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_parseBoolean</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="n">true_accepted_values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'true'</span><span class="p">]</span>
    <span class="n">false_accepted_values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'false'</span><span class="p">]</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="n">true_accepted_values</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">new_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">false_accepted_values</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Parsing weird boolean, </span><span class="si">% r</span><span class="s1"> does not map to True or False'</span> <span class="o">%</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="o">=</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># Cannot import Namespace/XSD because of circular dependencies</span>
<span class="n">_XSD_PFX</span> <span class="o">=</span> <span class="s1">'http://www.w3.org/2001/XMLSchema#'</span>
<span class="n">_RDF_PFX</span> <span class="o">=</span> <span class="s1">'http://www.w3.org/1999/02/22-rdf-syntax-ns#'</span>

<span class="n">_RDF_XMLLITERAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_RDF_PFX</span> <span class="o">+</span> <span class="s1">'XMLLiteral'</span><span class="p">)</span>
<span class="n">_RDF_HTMLLITERAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_RDF_PFX</span> <span class="o">+</span> <span class="s1">'HTML'</span><span class="p">)</span>

<span class="n">_XSD_STRING</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'string'</span><span class="p">)</span>

<span class="n">_XSD_FLOAT</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'float'</span><span class="p">)</span>
<span class="n">_XSD_DOUBLE</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'double'</span><span class="p">)</span>
<span class="n">_XSD_DECIMAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'decimal'</span><span class="p">)</span>
<span class="n">_XSD_INTEGER</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'integer'</span><span class="p">)</span>
<span class="n">_XSD_BOOLEAN</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'boolean'</span><span class="p">)</span>

<span class="n">_XSD_DATETIME</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'dateTime'</span><span class="p">)</span>
<span class="n">_XSD_DATE</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'date'</span><span class="p">)</span>
<span class="n">_XSD_TIME</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'time'</span><span class="p">)</span>
<span class="n">_XSD_DURATION</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'duration'</span><span class="p">)</span>
<span class="n">_XSD_DAYTIMEDURATION</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'dayTimeDuration'</span><span class="p">)</span>
<span class="n">_XSD_YEARMONTHDURATION</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'yearMonthDuration'</span><span class="p">)</span>

<span class="n">_OWL_RATIONAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="s1">'http://www.w3.org/2002/07/owl#rational'</span><span class="p">)</span>
<span class="n">_XSD_HEXBINARY</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'hexBinary'</span><span class="p">)</span>
<span class="c1"># TODO: gYearMonth, gYear, gMonthDay, gDay, gMonth</span>

<span class="n">_NUMERIC_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_INTEGER</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'float'</span><span class="p">),</span>

    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'byte'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'int'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'long'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'negativeInteger'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'nonNegativeInteger'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'nonPositiveInteger'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'positiveInteger'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'short'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedByte'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedInt'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedLong'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedShort'</span><span class="p">),</span>

<span class="p">)</span>

<span class="c1"># these have "native" syntax in N3/SPARQL</span>
<span class="n">_PLAIN_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_INTEGER</span><span class="p">,</span>
    <span class="n">_XSD_BOOLEAN</span><span class="p">,</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
    <span class="n">_OWL_RATIONAL</span>
<span class="p">)</span>

<span class="c1"># these have special INF and NaN XSD representations</span>
<span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'float'</span><span class="p">),</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># the following types need special treatment for reasonable sorting because</span>
<span class="c1"># certain instances can't be compared to each other. We treat this by</span>
<span class="c1"># partitioning and then sorting within those partitions.</span>
<span class="n">_TOTAL_ORDER_CASTERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">datetime</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span>
        <span class="c1"># naive vs. aware</span>
        <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span>
    <span class="p">),</span>
    <span class="n">time</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span>
        <span class="c1"># naive vs. aware</span>
        <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span>
    <span class="p">),</span>
    <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">toxml</span><span class="p">(),</span>
<span class="p">}</span>


<span class="n">_STRING_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_STRING</span><span class="p">,</span>
    <span class="n">_RDF_XMLLITERAL</span><span class="p">,</span>
    <span class="n">_RDF_HTMLLITERAL</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'normalizedString'</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'token'</span><span class="p">)</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_py2literal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">,</span> <span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">castFunc</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">castFunc</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">dType</span>
    <span class="k">elif</span> <span class="n">dType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dType</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_castPythonToLiteral</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Casts a tuple of a python type and a special datatype URI to a tuple of the lexical value and a</span>
<span class="sd">    datatype URI (or None)</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pType</span><span class="p">,</span> <span class="n">dType</span><span class="p">),</span> <span class="n">castFunc</span> <span class="ow">in</span> <span class="n">_SpecificPythonToXSDRules</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dType</span> <span class="o">==</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_py2literal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">,</span> <span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">pType</span><span class="p">,</span> <span class="p">(</span><span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_GenericPythonToXSDRules</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_py2literal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">,</span> <span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="kc">None</span>  <span class="c1"># TODO: is this right for the fall through case?</span>


<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>

<span class="c1"># Mappings from Python types to XSD datatypes and back (borrowed from sparta)</span>
<span class="c1"># datetime instances are also instances of date... so we need to order these.</span>

<span class="c1"># SPARQL/Turtle/N3 has shortcuts for integer, double, decimal</span>
<span class="c1"># python has only float - to be in tune with sparql/n3/turtle</span>
<span class="c1"># we default to XSD.double for float literals</span>

<span class="c1"># python ints are promoted to longs when overflowing</span>
<span class="c1"># python longs have no limit</span>
<span class="c1"># both map to the abstract integer type,</span>
<span class="c1"># rather than some concrete bit-limited datatype</span>
<span class="n">_GenericPythonToXSDRules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_DOUBLE</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">_XSD_BOOLEAN</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_INTEGER</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">long_type</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_INTEGER</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_DECIMAL</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">datetime</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_DATETIME</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_DATE</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_TIME</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">Duration</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">duration_isoformat</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">_XSD_DURATION</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">timedelta</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">duration_isoformat</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">_XSD_DAYTIMEDURATION</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">,</span> <span class="p">(</span><span class="n">_writeXML</span><span class="p">,</span> <span class="n">_RDF_XMLLITERAL</span><span class="p">)),</span>
    <span class="c1"># this is a bit dirty - by accident the html5lib parser produces</span>
    <span class="c1"># DocumentFragments, and the xml parser Documents, letting this</span>
    <span class="c1"># decide what datatype to use makes roundtripping easier, but it a</span>
    <span class="c1"># bit random</span>
    <span class="p">(</span><span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">DocumentFragment</span><span class="p">,</span> <span class="p">(</span><span class="n">_writeXML</span><span class="p">,</span> <span class="n">_RDF_HTMLLITERAL</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">Fraction</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_OWL_RATIONAL</span><span class="p">))</span>
<span class="p">]</span>

<span class="n">_SpecificPythonToXSDRules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">string_types</span><span class="p">,</span> <span class="n">_XSD_HEXBINARY</span><span class="p">),</span> <span class="n">hexlify</span><span class="p">),</span>
<span class="p">]</span>
<span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
    <span class="n">_SpecificPythonToXSDRules</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">_XSD_HEXBINARY</span><span class="p">),</span> <span class="n">hexlify</span><span class="p">))</span>

<span class="n">XSDToPython</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># plain literals map directly to value space</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'time'</span><span class="p">):</span> <span class="n">parse_time</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'date'</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'gYear'</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'gYearMonth'</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'dateTime'</span><span class="p">):</span> <span class="n">parse_datetime</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'duration'</span><span class="p">):</span> <span class="n">parse_duration</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'dayTimeDuration'</span><span class="p">):</span> <span class="n">parse_duration</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'yearMonthDuration'</span><span class="p">):</span> <span class="n">parse_duration</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'hexBinary'</span><span class="p">):</span> <span class="n">_unhexlify</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'string'</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'normalizedString'</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'token'</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'language'</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'boolean'</span><span class="p">):</span> <span class="n">_parseBoolean</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'decimal'</span><span class="p">):</span> <span class="n">Decimal</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'integer'</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'nonPositiveInteger'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'long'</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'nonNegativeInteger'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'negativeInteger'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'int'</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedLong'</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'positiveInteger'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'short'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedInt'</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'byte'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedShort'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'unsignedByte'</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'float'</span><span class="p">):</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'double'</span><span class="p">):</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'base64Binary'</span><span class="p">):</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">'anyURI'</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">_RDF_XMLLITERAL</span><span class="p">:</span> <span class="n">_parseXML</span><span class="p">,</span>
    <span class="n">_RDF_HTMLLITERAL</span><span class="p">:</span> <span class="n">_parseHTML</span>
<span class="p">}</span>

<span class="n">_toPythonMapping</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">_toPythonMapping</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">XSDToPython</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Map a lexical form to the value-space for the given datatype</span>
<span class="sd">    :returns: a python object for the value or ``None``</span>
<span class="sd">    """</span>
    <span class="n">convFunc</span> <span class="o">=</span> <span class="n">_toPythonMapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">convFunc</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convFunc</span><span class="p">(</span><span class="n">lexical</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># not a valid lexical representation for this dt</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">convFunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># no conv func means 1-1 lexical&lt;-&gt;value-space mapping</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="n">lexical</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="n">lexical</span><span class="p">,</span> <span class="s1">'utf-8'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no convFunc - unknown data-type</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="n">pythontype</span><span class="p">,</span> <span class="n">constructor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lexicalizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datatype_specific</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    register a new datatype&lt;-&gt;pythontype binding</span>

<span class="sd">    :param constructor: an optional function for converting lexical forms</span>
<span class="sd">                        into a Python instances, if not given the pythontype</span>
<span class="sd">                        is used directly</span>

<span class="sd">    :param lexicalizer: an optional function for converting python objects to</span>
<span class="sd">                        lexical form, if not given object.__str__ is used</span>

<span class="sd">    :param datatype_specific: makes the lexicalizer function be accessible</span>
<span class="sd">                              from the pair (pythontype, datatype) if set to True</span>
<span class="sd">                              or from the pythontype otherwise.  False by default</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">datatype_specific</span> <span class="ow">and</span> <span class="n">datatype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"No datatype given for a datatype-specific binding"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="n">_toPythonMapping</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">"datatype '</span><span class="si">%s</span><span class="s2">' was already bound. Rebinding."</span> <span class="o">%</span>
                       <span class="n">datatype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">constructor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">constructor</span> <span class="o">=</span> <span class="n">pythontype</span>
    <span class="n">_toPythonMapping</span><span class="p">[</span><span class="n">datatype</span><span class="p">]</span> <span class="o">=</span> <span class="n">constructor</span>
    <span class="k">if</span> <span class="n">datatype_specific</span><span class="p">:</span>
        <span class="n">_SpecificPythonToXSDRules</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">pythontype</span><span class="p">,</span> <span class="n">datatype</span><span class="p">),</span> <span class="n">lexicalizer</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_GenericPythonToXSDRules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pythontype</span><span class="p">,</span> <span class="p">(</span><span class="n">lexicalizer</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A Variable - this is used for querying, or in Formula aware</span>
<span class="sd">    graphs, where Variables can stored in the graph</span>
<span class="sd">    """</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">"Attempted to create variable with empty string as name!"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'?'</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">Variable</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">"rdflib.term.Variable"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">return</span> <span class="s2">"""</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)"""</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"?</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"?</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>


<span class="k">class</span> <span class="nc">Statement</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">triple</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">triple</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">"Class Statement is deprecated, and will be removed in "</span> <span class="o">+</span>
            <span class="s2">"the future. If you use this please let rdflib-dev know!"</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span> <span class="n">context</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Statement</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="c1"># Nodes are ordered like this</span>
<span class="c1"># See http://www.w3.org/TR/sparql11-query/#modOrderBy</span>
<span class="c1"># we leave "space" for more subclasses of Node elsewhere</span>
<span class="c1"># default-dict to grazefully fail for new subclasses</span>
<span class="n">_ORDERING</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">_ORDERING</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="n">BNode</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">:</span> <span class="mi">40</span>
<span class="p">})</span>


<span class="k">def</span> <span class="nf">_isEqualXMLNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">xml.dom.minidom</span> <span class="kn">import</span> <span class="n">Node</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">():</span>
        <span class="c1"># Recursion through the children</span>
        <span class="c1"># In Python2, the semantics of 'map' is such that the check on</span>
        <span class="c1"># length would be unnecessary. In Python 3,</span>
        <span class="c1"># the semantics of map has changed (why, oh why???) and the check</span>
        <span class="c1"># for the length becomes necessary...</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">childNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">childNodes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">oc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">childNodes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">childNodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_isEqualXMLNode</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">oc</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># if we got here then everything is fine:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">nodeType</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_FRAGMENT_NODE</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">()</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">ELEMENT_NODE</span><span class="p">:</span>
        <span class="c1"># Get the basics right</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tagName</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tagName</span> <span class="ow">and</span>
                <span class="n">node</span><span class="o">.</span><span class="n">namespaceURI</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">namespaceURI</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Handle the (namespaced) attributes; the namespace setting key</span>
        <span class="c1"># should be ignored, though</span>
        <span class="c1"># Note that the minidom orders the keys already, so we do not have</span>
        <span class="c1"># to worry about that, which is a bonus...</span>
        <span class="n">n_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keysNS</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'http://www.w3.org/2000/xmlns/'</span><span class="p">]</span>
        <span class="n">o_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keysNS</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'http://www.w3.org/2000/xmlns/'</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_keys</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">n_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">o_keys</span>
                    <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">getAttributeNS</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">getAttributeNS</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># if we got here, the attributes are all right, we can go down</span>
        <span class="c1"># the tree recursively</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">()</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">Node</span><span class="o">.</span><span class="n">TEXT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">COMMENT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">CDATA_SECTION_NODE</span><span class="p">,</span>
            <span class="n">Node</span><span class="o">.</span><span class="n">NOTATION_NODE</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">PROCESSING_INSTRUCTION_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">target</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">ENTITY_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeValue</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nodeValue</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_TYPE_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">publicId</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">publicId</span> \
            <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">systemId</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">Id</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># should not happen, in fact</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s1">'I dont know how to compare XML Node type: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2021, Arcangelo Massari.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>